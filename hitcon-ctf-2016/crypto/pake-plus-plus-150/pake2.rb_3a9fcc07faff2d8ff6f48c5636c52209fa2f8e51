#!/usr/bin/env ruby

# {{{ === requires ===
require 'digest'
require 'json'
require 'openssl'
require 'securerandom'
require 'timeout'
# }}}

Timeout.timeout(240) do
  $stdout.sync = true
  # For xinetd
  Dir.chdir(File.dirname(__FILE__))

# {{{ === utility functions ===
  # str_to_num('AB') = 0x4142 = 16706
  def str_to_num(s)
    s.unpack('H*')[0].to_i(16)
  end

  # x^y (mod z)
  def pow(x, y, z)
    x.to_bn.mod_exp(y, z).to_i
  end

  # x^(-1) (mod y)
  def inv(x, y)
    x.to_bn.mod_inverse(y).to_i
  end

  def is_safe_prime(p)
    p.to_bn.prime? && ((p-1)/2).to_bn.prime?
  end
# }}}

# {{{ === proof of work ===
  # XXX: We only call this function once, no need to wrap it in a function.
  # def proof_of_work
    x = SecureRandom.random_bytes(6)
    puts 'Robot test'
    puts "prefix: #{[x].pack('m0')}"
    r = gets.strip.unpack('m0')[0]
    r = Digest::SHA1.digest(x + r)
    # We want the digest to begin with 23 bits of zero.
    # [0..15]
    unless r.start_with?("\0\0")
      puts 'FAIL! GO AWAY!'
      exit
    end
    c = r[2].ord
    r, s = c / 2, c % 2
    # r: [16..22], s: [23]
    unless r == 0
      puts 'FAIL! GO AWAY!'
      exit
    end
    print 'Good job! '
  # end
  # proof_of_work
# }}}

# === Main starts here ===

  # Our list of safe primes.
  primes = <<-EOS.lines.map(&:to_i)
  285370232948523998980902649176998223002378361587332218493775786752826166161423082436982297888443231240619463576886971476889906175870272573060319231258784649665194518832695848032181036303102119334432612172767710672560390596241136280678425624046988433310588364872005613290545811367950034187020564546262381876467
  298619967637074381179969535203891334279037109216429406440598651658759350405543564192161651312771530156893413427058175045425757160212464963471306913768112396967665485652095651332292521663596653434043497333804676303590560939622585332770724390627970615864007468306226942254398801398715678948641382895998651226267
  298049748677563805780319663628819960854615659462424022507630185085633596966175010904970480952385372951172828141165347514534458425242085310886903778569556019799929063608007455863031014344586675081359600240391009588905845818495639778564642452193502269859322492791462878008970754999615280381704729202349939626979
  328517416048692886037451935540065593512994462002198409216093662374867257380362145180594029938263095492728312598227855130627235361314817436633177786884494030007864152308901161140111969980403722704138376439893801083486571959976238463025246682645769458504940248785078868650651872930977987712522710703736396657387
  282394389781374199382509925858094901774563649174745796339967395605116291562054020073955455338401167970080036287402587308354538500190221028476399923564634339732689941702464496890308354549764266506953808881910012117986860385319905877301417806557760524821229657147194856430018136428864202922733288830153277890659
  323103830544117987011024048071694067643223166857443601288678625077550042396643402625692490043863582981782378717042298512462563264457088124223575174164921578128007273839310675925364961100802146846497562297376569657569712628347758371790366124768858903423043207000026049079160253301902404207920358137230602539643
  302103350544659483531131684583742544907887033086695553935842864801685693649953339273310786890360791425112212069129996061391578244584149171226282625727635376367322205108426287980490462476857893899354488802419996817239780781622440165425711955277936322570946121224712118336303389972089563531346006960196427704219
  274405967560432033789798999119890457360306712028734789799802515309420810630484361406114488871989143593759704555407742610118391422809479638606936598462341976320928990585877751200977318034499800109548890002507225944134922612505410751207789339655283747859299017222586400523098060723763539689025418276604564593619
  EOS
  fail unless primes.all?{|p| is_safe_prime(p)}

  # Secret password
  # password is a random string.
  # We don't need multiple password now since this one have enough entropy already.
  password = IO.read('password2').strip
  fail unless password =~ /\A[a-zA-Z0-9]{20}\z/
  password = Digest::SHA512.hexdigest(password).to_i(16)

  # More secrets!
  flag = IO.read('./flag2.txt').strip
  fail unless flag =~ /\Ahitcon\{[a-zA-Z0-9_]+\}\z/
  fail unless flag.size <= 60
  flag = str_to_num(flag)

  # Print banner
  puts
  puts 'This is a simple secret-flag-sharing server.'
  puts

  # This is the key to be xor-ed
  key = 0

  # 2 rounds for better security.
  2.times do |i|
    puts "Round #{i + 1}"

    # Perform a simple PAKE handshake
    # You can find explanation in http://goo.gl/3foagq  (In code comment :D)
    # We use multiple primes because... why not :P
    p = primes[SecureRandom.random_number(primes.size)]
    puts "p = #{p}"

    w = pow(password, 2, p)  # NO to Legendre
    b = 2 + SecureRandom.random_number(p - 2)
    bb = pow(w, b, p)
    puts "Server send #{bb}"

    aa = gets.to_i
    if aa < 514 || aa >= p - 514
      puts 'CHEATER!'
      exit
    end

    k = pow(aa, b, p)
    key ^= Digest::SHA512.hexdigest(k.to_s).to_i(16)
  end

  # encrypt the flag!
  flag ^= key
  puts "Flag is (of course after encryption :D): #{flag}"

  # YAY!
  puts 'All done. Bye~'
  exit
end

# vim: fdm=marker:commentstring=\ \"\ %s:nowrap:autoread
